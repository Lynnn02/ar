<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Viewer</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        .ar-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            color: #333;
            font-weight: bold;
        }
        
        .control-btn:hover {
            background: white;
            transform: scale(1.1);
        }
        
        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            color: #333;
        }
        
        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
            z-index: 1000;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1001;
            text-align: center;
        }
        
        .hidden {
            display: none;
        }
        
        /* Responsive adjustments */
        @media (max-width: 480px) {
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            .close-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            .info-panel {
                font-size: 12px;
                padding: 10px;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div>Initializing AR...</div>
        <div style="font-size: 14px; margin-top: 10px;">Point your camera at a flat surface</div>
    </div>
    
    <div id="info-panel" class="info-panel hidden">
        <div><strong>AR Controls:</strong></div>
        <div>• Pinch to zoom</div>
        <div>• Drag to rotate</div>
        <div>• Tap to place model</div>
        <div id="model-info"></div>
    </div>
    
    <button class="close-btn" onclick="closeAR()">×</button>
    
    <a-scene
        id="ar-scene"
        embedded
        arjs="sourceType: webcam; debugUIEnabled: true; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; antialias: true;"
        gesture-detector
        loading-screen="enabled: false">
        
        <a-assets>
            <a-asset-item id="normal-model" src="./model.glb" crossorigin="anonymous"></a-asset-item>
            <a-asset-item id="faulty-model" src="./acc4.glb" crossorigin="anonymous"></a-asset-item>
        </a-assets>
        
        <a-camera
            id="camera"
            look-controls="enabled: false"
            arjs-look-controls="smoothingFactor: 0.1"
            wasd-controls="enabled: false">
        </a-camera>
        
        <!-- Marker-based fallback -->
        <a-marker preset="hiro" id="marker">
            <a-entity
                id="model-entity"
                gltf-model=""
                position="0 0.5 0"
                scale="1 1 1"
                rotation="-90 0 0"
                gesture-handler="minScale: 0.1; maxScale: 3"
                animation-mixer
                visible="true">
            </a-entity>
        </a-marker>
        
        <!-- Markerless entity -->
        <a-entity
            id="markerless-entity"
            gltf-model=""
            position="0 0 -2"
            scale="0.8 0.8 0.8"
            rotation="0 0 0"
            gesture-handler="minScale: 0.1; maxScale: 3"
            animation-mixer
            visible="false">
        </a-entity>
        
        <a-plane
            id="ground"
            position="0 -0.5 -2"
            rotation="-90 0 0"
            width="4"
            height="4"
            color="#7BC8A4"
            opacity="0.3"
            visible="false">
        </a-plane>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#ffffff" intensity="0.8"></a-light>
        <a-light type="directional" position="1 1 1" color="#ffffff" intensity="0.5"></a-light>
    </a-scene>
    
    <div class="ar-controls">
        <button class="control-btn" onclick="resetModel()" title="Reset Position">⌂</button>
        <button class="control-btn" onclick="toggleGround()" title="Toggle Ground">⊞</button>
        <button class="control-btn" onclick="toggleInfo()" title="Toggle Info">ⓘ</button>
    </div>
    
    <script>
        let currentModel = 'normal';
        let modelEntity;
        let markerlessEntity;
        let groundPlane;
        let infoPanel;
        let isGroundVisible = false;
        let isInfoVisible = false;
        let useMarkerless = false;
        
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentModel = urlParams.get('model') || 'normal';
        
        // Initialize AR scene
        document.addEventListener('DOMContentLoaded', function() {
            modelEntity = document.getElementById('model-entity');
            markerlessEntity = document.getElementById('markerless-entity');
            groundPlane = document.getElementById('ground');
            infoPanel = document.getElementById('info-panel');
            
            console.log('Initializing AR with model:', currentModel);
            
            // Load the appropriate model
            loadModel(currentModel);
            
            // Update info panel
            updateModelInfo();
            
            // Check for marker detection
            const marker = document.getElementById('marker');
            marker.addEventListener('markerFound', function() {
                console.log('Marker found - using marker-based AR');
                useMarkerless = false;
                modelEntity.setAttribute('visible', true);
                markerlessEntity.setAttribute('visible', false);
            });
            
            marker.addEventListener('markerLost', function() {
                console.log('Marker lost - switching to markerless');
                useMarkerless = true;
                modelEntity.setAttribute('visible', false);
                markerlessEntity.setAttribute('visible', true);
            });
            
            // Hide loading after scene is ready
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                infoPanel.classList.remove('hidden');
                isInfoVisible = true;
                
                // Default to markerless if no marker detected
                if (!useMarkerless) {
                    console.log('No marker detected - using markerless AR');
                    useMarkerless = true;
                    modelEntity.setAttribute('visible', false);
                    markerlessEntity.setAttribute('visible', true);
                }
            }, 5000);
        });
        
        function loadModel(modelType) {
            const modelSrc = modelType === 'normal' ? '#normal-model' : '#faulty-model';
            console.log('Loading model:', modelSrc);
            
            // Load model for both entities
            if (modelEntity) {
                modelEntity.setAttribute('gltf-model', modelSrc);
                console.log('Model loaded for marker entity');
            }
            if (markerlessEntity) {
                markerlessEntity.setAttribute('gltf-model', modelSrc);
                console.log('Model loaded for markerless entity');
            }
            
            currentModel = modelType;
            
            // Add model load event listeners
            const checkModelLoad = (entity, name) => {
                entity.addEventListener('model-loaded', function() {
                    console.log(`${name} model loaded successfully`);
                });
                entity.addEventListener('model-error', function(error) {
                    console.error(`${name} model failed to load:`, error);
                });
            };
            
            if (modelEntity) checkModelLoad(modelEntity, 'Marker');
            if (markerlessEntity) checkModelLoad(markerlessEntity, 'Markerless');
        }
        
        function updateModelInfo() {
            const modelInfo = document.getElementById('model-info');
            const info = currentModel === 'normal' 
                ? '<div style="margin-top: 10px;"><strong>Normal Airflow</strong><br>Standard operation model</div>'
                : '<div style="margin-top: 10px;"><strong>Faulty Airflow</strong><br>Diagnostic model</div>';
            modelInfo.innerHTML = info;
        }
        
        function resetModel() {
            if (useMarkerless && markerlessEntity) {
                markerlessEntity.setAttribute('position', '0 0 -2');
                markerlessEntity.setAttribute('rotation', '0 0 0');
                markerlessEntity.setAttribute('scale', '0.8 0.8 0.8');
                console.log('Reset markerless model');
            } else if (modelEntity) {
                modelEntity.setAttribute('position', '0 0.5 0');
                modelEntity.setAttribute('rotation', '-90 0 0');
                modelEntity.setAttribute('scale', '1 1 1');
                console.log('Reset marker model');
            }
        }
        
        function toggleGround() {
            isGroundVisible = !isGroundVisible;
            groundPlane.setAttribute('visible', isGroundVisible);
        }
        
        function toggleInfo() {
            isInfoVisible = !isInfoVisible;
            if (isInfoVisible) {
                infoPanel.classList.remove('hidden');
            } else {
                infoPanel.classList.add('hidden');
            }
        }
        
        function closeAR() {
            window.location.href = 'index.html';
        }
        
        // Gesture handling for mobile
        AFRAME.registerComponent('gesture-detector', {
            schema: {
                element: {default: ''}
            },
            
            init: function() {
                this.targetElement = this.data.element && document.querySelector(this.data.element);
                
                if (!this.targetElement) {
                    this.targetElement = this.el;
                }
                
                this.internalState = {
                    previousState: null
                };
                
                this.emitGestureEvent = this.emitGestureEvent.bind(this);
                this.targetElement.addEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.addEventListener('touchend', this.emitGestureEvent);
                this.targetElement.addEventListener('touchmove', this.emitGestureEvent);
            },
            
            remove: function() {
                this.targetElement.removeEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchend', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchmove', this.emitGestureEvent);
            },
            
            emitGestureEvent(event) {
                const currentState = this.getTouchState(event);
                const previousState = this.internalState.previousState;
                
                const gestureContinues = previousState &&
                    currentState &&
                    currentState.touchCount == previousState.touchCount;
                
                const gestureEnded = previousState && !gestureContinues;
                const gestureStarted = currentState && !gestureContinues;
                
                if (gestureEnded) {
                    const eventName = this.getEventPrefix(previousState.touchCount) + 'ended';
                    this.el.emit(eventName, previousState);
                    this.internalState.previousState = null;
                }
                
                if (gestureStarted) {
                    currentState.startTime = performance.now();
                    currentState.startPosition = currentState.position;
                    currentState.startSpread = currentState.spread;
                    const eventName = this.getEventPrefix(currentState.touchCount) + 'started';
                    this.el.emit(eventName, currentState);
                    this.internalState.previousState = currentState;
                }
                
                if (gestureContinues) {
                    const eventName = this.getEventPrefix(currentState.touchCount) + 'moved';
                    this.el.emit(eventName, currentState);
                    this.internalState.previousState = currentState;
                }
            },
            
            getTouchState: function(event) {
                if (event.touches.length === 0) {
                    return null;
                }
                
                const touchList = [];
                for (let i = 0; i < event.touches.length; i++) {
                    touchList.push(event.touches[i]);
                }
                
                const touchCount = touchList.length;
                const position = this.getCenterOfTouches(touchList);
                const spread = touchCount >= 2 ? this.getSpreadOfTouches(touchList) : 0;
                
                return {
                    touchCount: touchCount,
                    position: position,
                    spread: spread,
                    touches: touchList
                };
            },
            
            getCenterOfTouches: function(touchList) {
                let x = 0, y = 0;
                for (let touch of touchList) {
                    x += touch.clientX;
                    y += touch.clientY;
                }
                return {
                    x: x / touchList.length,
                    y: y / touchList.length
                };
            },
            
            getSpreadOfTouches: function(touchList) {
                if (touchList.length < 2) {
                    return 0;
                }
                
                const centerPoint = this.getCenterOfTouches(touchList);
                let spread = 0;
                
                for (let touch of touchList) {
                    spread += Math.sqrt(
                        Math.pow(centerPoint.x - touch.clientX, 2) +
                        Math.pow(centerPoint.y - touch.clientY, 2)
                    );
                }
                
                return spread / touchList.length;
            },
            
            getEventPrefix: function(touchCount) {
                const numberNames = ['one', 'two', 'three', 'many'];
                return numberNames[Math.min(touchCount, 4) - 1];
            }
        });
        
        AFRAME.registerComponent('gesture-handler', {
            schema: {
                enabled: {default: true},
                rotationFactor: {default: 5},
                minScale: {default: 0.3},
                maxScale: {default: 8},
            },
            
            init: function() {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                
                this.isVisible = false;
                this.initialScale = this.el.object3D.scale.clone();
                this.scaleFactor = 1;
                
                this.el.sceneEl.addEventListener('onefingermove', this.handleRotation);
                this.el.sceneEl.addEventListener('twofingermove', this.handleScale);
                this.el.sceneEl.addEventListener('threeFingerMove', this.handleScale);
            },
            
            remove: function() {
                this.el.sceneEl.removeEventListener('onefingermove', this.handleRotation);
                this.el.sceneEl.removeEventListener('twofingermove', this.handleScale);
                this.el.sceneEl.removeEventListener('threeFingerMove', this.handleScale);
            },
            
            handleRotation: function(event) {
                if (this.isVisible) {
                    this.isVisible = this.el.object3D.visible;
                    return;
                }
                
                const rotationFactor = this.data.rotationFactor;
                const deltaY = event.detail.positionChange.x * rotationFactor;
                const deltaX = event.detail.positionChange.y * rotationFactor;
                
                this.el.object3D.rotation.y += deltaY * Math.PI / 180;
                this.el.object3D.rotation.x += deltaX * Math.PI / 180;
            },
            
            handleScale: function(event) {
                if (this.isVisible) {
                    this.isVisible = this.el.object3D.visible;
                    return;
                }
                
                this.scaleFactor *= 1 + (event.detail.spreadChange / event.detail.startSpread);
                
                this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
                
                this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
                this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
                this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
            }
        });
    </script>
</body>
</html>
