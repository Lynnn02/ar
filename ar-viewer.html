<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Viewer</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        .ar-controls {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 20px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
            padding: 0 20px;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            color: #333;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }
        
        .control-btn:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }
        
        .close-btn {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            color: #333;
            -webkit-tap-highlight-color: transparent;
        }
        
        .close-btn:active {
            background: #f0f0f0;
            transform: scale(0.95);
        }
        
        .info-panel {
            position: fixed;
            top: env(safe-area-inset-top, 60px);
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 1001;
            text-align: center;
            max-width: 280px;
            backdrop-filter: blur(5px);
        }
        
        .hidden {
            display: none;
        }
        
        /* Responsive adjustments */
        @media (max-width: 480px) {
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            .close-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            .info-panel {
                font-size: 12px;
                padding: 10px;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div>Initializing AR...</div>
        <div style="font-size: 14px; margin-top: 10px;">Point your camera at a flat surface</div>
    </div>
    
    <div id="info-panel" class="info-panel hidden">
        <div><strong>AR Controls:</strong></div>
        <div>• Pinch to zoom</div>
        <div>• Drag to rotate</div>
        <div>• Tap to place model</div>
        <div id="model-info"></div>
    </div>
    
    <button class="close-btn" onclick="closeAR()">×</button>
    
    <a-scene
        id="ar-scene"
        embedded
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true;"
        loading-screen="enabled: false">
        
        <a-assets>
            <a-asset-item id="normal-model" src="./model.glb"></a-asset-item>
            <a-asset-item id="faulty-model" src="./acc4.glb"></a-asset-item>
        </a-assets>
        
        <a-camera
            look-controls="enabled: false"
            arjs-look-controls="smoothingFactor: 0.1">
        </a-camera>
        
        <!-- Simple markerless AR -->
        <a-entity
            id="model-entity"
            gltf-model=""
            position="0 0 -1.5"
            scale="2 2 2"
            rotation="0 0 0"
            animation-mixer
            visible="true">
        </a-entity>
        
        <!-- Ground reference -->
        <a-plane
            id="ground"
            position="0 -0.5 -1.5"
            rotation="-90 0 0"
            width="2"
            height="2"
            color="#7BC8A4"
            opacity="0.3"
            visible="true">
        </a-plane>
        
        <!-- Better lighting -->
        <a-light type="ambient" color="#ffffff" intensity="1"></a-light>
        <a-light type="directional" position="0 1 0" color="#ffffff" intensity="0.8"></a-light>
    </a-scene>
    
    <div class="ar-controls">
        <button class="control-btn" onclick="resetModel()" title="Reset Position">⌂</button>
        <button class="control-btn" onclick="toggleGround()" title="Toggle Ground">⊞</button>
        <button class="control-btn" onclick="toggleInfo()" title="Toggle Info">ⓘ</button>
    </div>
    
    <script>
        let currentModel = 'normal';
        let modelEntity;
        let groundPlane;
        let infoPanel;
        let isGroundVisible = true;
        let isInfoVisible = false;
        
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentModel = urlParams.get('model') || 'normal';
        
        // Initialize AR scene
        document.addEventListener('DOMContentLoaded', function() {
            modelEntity = document.getElementById('model-entity');
            groundPlane = document.getElementById('ground');
            infoPanel = document.getElementById('info-panel');
            
            console.log('Initializing AR with model:', currentModel);
            
            // Load the appropriate model
            loadModel(currentModel);
            
            // Update info panel
            updateModelInfo();
            
            // Hide loading after scene is ready
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                if (infoPanel) {
                    infoPanel.classList.remove('hidden');
                    isInfoVisible = true;
                }
            }, 3000);
        });
        
        function loadModel(modelType) {
            const modelSrc = modelType === 'normal' ? '#normal-model' : '#faulty-model';
            console.log('Loading model:', modelSrc);
            
            if (modelEntity) {
                modelEntity.setAttribute('gltf-model', modelSrc);
                
                // Add model load event listeners
                modelEntity.addEventListener('model-loaded', function() {
                    console.log('Model loaded successfully:', modelType);
                    modelEntity.setAttribute('visible', true);
                });
                
                modelEntity.addEventListener('model-error', function(error) {
                    console.error('Model failed to load:', error);
                    // Try to make it visible anyway in case it's a false error
                    modelEntity.setAttribute('visible', true);
                });
            }
            
            currentModel = modelType;
        }
        
        function updateModelInfo() {
            const modelInfo = document.getElementById('model-info');
            const info = currentModel === 'normal' 
                ? '<div style="margin-top: 10px;"><strong>Normal Airflow</strong><br>Standard operation model</div>'
                : '<div style="margin-top: 10px;"><strong>Faulty Airflow</strong><br>Diagnostic model</div>';
            modelInfo.innerHTML = info;
        }
        
        function resetModel() {
            if (modelEntity) {
                modelEntity.setAttribute('position', '0 0 -1.5');
                modelEntity.setAttribute('rotation', '0 0 0');
                modelEntity.setAttribute('scale', '2 2 2');
                console.log('Reset model position');
            }
        }
        
        function toggleGround() {
            isGroundVisible = !isGroundVisible;
            groundPlane.setAttribute('visible', isGroundVisible);
        }
        
        function toggleInfo() {
            isInfoVisible = !isInfoVisible;
            if (isInfoVisible) {
                infoPanel.classList.remove('hidden');
            } else {
                infoPanel.classList.add('hidden');
            }
        }
        
        function closeAR() {
            window.location.href = 'index.html';
        }
        
        // Gesture handling for mobile
        AFRAME.registerComponent('gesture-detector', {
            schema: {
                element: {default: ''}
            },
            
            init: function() {
                this.targetElement = this.data.element && document.querySelector(this.data.element);
                
                if (!this.targetElement) {
                    this.targetElement = this.el;
                }
                
                this.internalState = {
                    previousState: null
                };
                
                this.emitGestureEvent = this.emitGestureEvent.bind(this);
                this.targetElement.addEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.addEventListener('touchend', this.emitGestureEvent);
                this.targetElement.addEventListener('touchmove', this.emitGestureEvent);
            },
            
            remove: function() {
                this.targetElement.removeEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchend', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchmove', this.emitGestureEvent);
            },
            
            emitGestureEvent(event) {
                const currentState = this.getTouchState(event);
                const previousState = this.internalState.previousState;
                
                const gestureContinues = previousState &&
                    currentState &&
                    currentState.touchCount == previousState.touchCount;
                
                const gestureEnded = previousState && !gestureContinues;
                const gestureStarted = currentState && !gestureContinues;
                
                if (gestureEnded) {
                    const eventName = this.getEventPrefix(previousState.touchCount) + 'ended';
                    this.el.emit(eventName, previousState);
                    this.internalState.previousState = null;
                }
                
                if (gestureStarted) {
                    currentState.startTime = performance.now();
                    currentState.startPosition = currentState.position;
                    currentState.startSpread = currentState.spread;
                    const eventName = this.getEventPrefix(currentState.touchCount) + 'started';
                    this.el.emit(eventName, currentState);
                    this.internalState.previousState = currentState;
                }
                
                if (gestureContinues) {
                    const eventName = this.getEventPrefix(currentState.touchCount) + 'moved';
                    this.el.emit(eventName, currentState);
                    this.internalState.previousState = currentState;
                }
            },
            
            getTouchState: function(event) {
                if (event.touches.length === 0) {
                    return null;
                }
                
                const touchList = [];
                for (let i = 0; i < event.touches.length; i++) {
                    touchList.push(event.touches[i]);
                }
                
                const touchCount = touchList.length;
                const position = this.getCenterOfTouches(touchList);
                const spread = touchCount >= 2 ? this.getSpreadOfTouches(touchList) : 0;
                
                return {
                    touchCount: touchCount,
                    position: position,
                    spread: spread,
                    touches: touchList
                };
            },
            
            getCenterOfTouches: function(touchList) {
                let x = 0, y = 0;
                for (let touch of touchList) {
                    x += touch.clientX;
                    y += touch.clientY;
                }
                return {
                    x: x / touchList.length,
                    y: y / touchList.length
                };
            },
            
            getSpreadOfTouches: function(touchList) {
                if (touchList.length < 2) {
                    return 0;
                }
                
                const centerPoint = this.getCenterOfTouches(touchList);
                let spread = 0;
                
                for (let touch of touchList) {
                    spread += Math.sqrt(
                        Math.pow(centerPoint.x - touch.clientX, 2) +
                        Math.pow(centerPoint.y - touch.clientY, 2)
                    );
                }
                
                return spread / touchList.length;
            },
            
            getEventPrefix: function(touchCount) {
                const numberNames = ['one', 'two', 'three', 'many'];
                return numberNames[Math.min(touchCount, 4) - 1];
            }
        });
        
        AFRAME.registerComponent('gesture-handler', {
            schema: {
                enabled: {default: true},
                rotationFactor: {default: 5},
                minScale: {default: 0.3},
                maxScale: {default: 8},
            },
            
            init: function() {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);
                
                this.isVisible = false;
                this.initialScale = this.el.object3D.scale.clone();
                this.scaleFactor = 1;
                
                this.el.sceneEl.addEventListener('onefingermove', this.handleRotation);
                this.el.sceneEl.addEventListener('twofingermove', this.handleScale);
                this.el.sceneEl.addEventListener('threeFingerMove', this.handleScale);
            },
            
            remove: function() {
                this.el.sceneEl.removeEventListener('onefingermove', this.handleRotation);
                this.el.sceneEl.removeEventListener('twofingermove', this.handleScale);
                this.el.sceneEl.removeEventListener('threeFingerMove', this.handleScale);
            },
            
            handleRotation: function(event) {
                if (this.isVisible) {
                    this.isVisible = this.el.object3D.visible;
                    return;
                }
                
                const rotationFactor = this.data.rotationFactor;
                const deltaY = event.detail.positionChange.x * rotationFactor;
                const deltaX = event.detail.positionChange.y * rotationFactor;
                
                this.el.object3D.rotation.y += deltaY * Math.PI / 180;
                this.el.object3D.rotation.x += deltaX * Math.PI / 180;
            },
            
            handleScale: function(event) {
                if (this.isVisible) {
                    this.isVisible = this.el.object3D.visible;
                    return;
                }
                
                this.scaleFactor *= 1 + (event.detail.spreadChange / event.detail.startSpread);
                
                this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
                
                this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
                this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
                this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
            }
        });
    </script>
</body>
</html>
